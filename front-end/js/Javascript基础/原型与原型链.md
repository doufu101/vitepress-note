作为一名前端开发,我们知道 js 是构成网页的核心技术,是我们生存的根本,就好比房子的根基,重中之重,根基根深蒂固,未来的路才会走的更远。  
我们知道在 js 中有三座大山 **原型与原型链** , **作用域与闭包** , **异步编程**。  
那么今天我们就先来剖析一下原型与原型链吧!

> **了解真相，才能获得真正的自由**

## 一. 深入理解原型

### 1.1 什么是原型? 原型对象的由来与作用

原型是一个非常核心的概念,然而这也是困扰很多前端初学者们的一个难点;首先它是实现对象之间继承机制的基础,也是理解 JavaScript 面向对象编程的关键。

> 这里涵盖一个对象的知识点：在 js 中对象除原始类型外其他的都是对象类型，但在某些情况下原始类型也会被包装成一个临时对象，比如当你访问一个字符串的 length()方法时,JavaScript 会临时将这个字符串包装成一个 string 对象,方法调用完成之后在丢弃这个临时对象。

原型它是每个 js 对象内部的一个特殊属性（称为[[prototype]]或者可以访问的**proto**属性）,它指向另一个对象，这个被指向的对象就是原型对象。  
那么问题来了，既然都是指向的原型为啥需要两种方式呢？  
它们都表示对象的原型。但是，它们在标准性和可访问性上有区别：

1. 设计原则和规范：[[prototype]]是 ECMAScript 规范中定义的内部属性，它的存在是为了描述 JavaScript 中面向对象编程的一个核心机制--原型继承,简单理解就是一个对象原型继承的标识
   它不是直接提供给程序员使用的 api，所以不能访问,每当创建一个新对象时,无论是通过字面量、构造函数还是 Object.create 方法,js 引擎都会为这个新对象设置一个内部的[[prototype]]链接，这个链接通常指向的就是该对象的原型对象；那么这个原型对象是个啥呢？

   > 这个原型对象是一个普通的对象，它拥有自己的属性和方法，这些属性和方法既可以是 js 引擎创建的也可以是开发者自定义的，因为任何对象都可以是原型对象，该对象在作为其他对象的原型时，其上的属性和方法都可以被继承。

2. 历史原因与兼容性：**proto**最早是非标准的，但它在早期的 js 实现中被广泛的使用，主要是为了给开发者提供一种简便的方式来访问和修改对象的原型，是可以访问的。随着时间的推移，已经被许多库，框架和开发者所依赖，所以现在 js 引擎大多保留了对它的支持。

总结：两者在功能上都是用来表示当前对象的原型对象，只是**proto**提供了对这一内部机制的直接操作接口，而[[Prototype]]则是这一机制的理论基础，存在于语言的内部实现中。鉴于**proto**的非标准性，ECMAScript 标准推荐使用 Object.getPrototypeOf()方法来获取对象的原型（等同于[[Prototype]]），使用 Object.setPrototypeOf()来设置对象的原型，以保证代码的兼容性和未来可维护性。

### 1.2 构造函数与原型的关系: constructor 属性

### 1.3 原型属性的继承: 如何通过原型链访问对象的方法和属性呢?

### 1.4 实例与原型之间的关系: **proto**属性

### 1.5 修改显示原型: Object.setPrototypeOf()和 Object.getPrototypeOf()

## 二. 原型链探索

### 2.1 什么是原型链?

### 2.2 原型链的形成与工作原理: 如果通过原型链查找属性和方法

### 2.3 原型链的末端:null

### 2.4 原型链上的属性覆盖与查找规则

### 2.5 深度剖析: 多层原型链和继承关系
